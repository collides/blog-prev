<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="专注 WEB 开发的技术博客"><title>网络相关(1) | yunhui's Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">网络相关(1)</h1><a id="logo" href="/.">yunhui's Blog</a><p class="description">学习弯道超车的技巧！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">网络相关(1)</h1><div class="post-meta"><a href="/2018/02/01/网络相关总结(1)/#comments" class="comment-count"></a><p><span class="date">Feb 01, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="网络分层TCP-IP-与HTTP"><a href="#网络分层TCP-IP-与HTTP" class="headerlink" title="网络分层TCP/IP 与HTTP"></a>网络分层TCP/IP 与HTTP</h1><p>目前存在的两种网络分层模型：OSI模型和TCP/IP模型，OSI模型一共分为7层，TCP/IP与它类似但是只分为四层。</p>
<h1 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h1><p>OSI的全程是 Open systems interconncection，开放系统互联，它由ISO制定。OSI是网络通信的一种通用框架，它分为七层，并且定义了每一层数据的处理方法。</p>
<ul>
<li><p>应用层</p>
<p>这里的 “应用” 要和应用程序区别开，当用户使用浏览器来打开页面时，需要利用DNS提供域名解析服务，来获取IP地址然后通过HTTP协议来下载页面内容，这个过程出现了两个协议（DNS,HTTP）都是工作在应用层上的协议，还有其他常用协议(FTP,DHCP,POP3)。</p>
</li>
<li><p>表示层</p>
<p>这里的 “表示”是指数据的表示，主要功能：转换，压缩和加密，工作在表示层的加密协议最常用的就是SSL（Secure Sockets Layer）。加密协议并不一定需要工作在表示层，如IPSec (因特网协议安全) 就工作在第三层网络层中。</p>
</li>
<li><p>会话层</p>
<p>可以把 “会话” 理解为两个应用程序进程之间的逻辑连接，两个应用程序通过这个连接进行在一段时间内交换数据。会话层的作用就是创建、管理和终止会话提供必要的方法。这些方法主要是以API的形式出现。会话层还负责管理和确定传输模式。计算机可以由三种模式来传输数据：单向（数据只能单向传输）、半双工（允许数据可以单向传输但是一个时刻只能有一个方向传输，不可以同时传输）、全双工（数据可以同时双向传输）。</p>
</li>
<li><p>传输层</p>
<p>传输层提供数据传输的服务，这里的“传输”指的是端对端 或者主机对主机的传输。</p>
<p>传输层上最重要的两个协议是TCP和UDP。</p>
<p>​    TCP（传输控制协议）</p>
<p>​    TCP在传输数据之前必须先建立一个连接。TCP做了很多工作来提供可靠的数据传输，包括建          立，管理和终止连接，确认和重传。同时TCP还提供分段和重组，流量控制等。</p>
<p>​    UDP（用户数据报协议）</p>
<p>​    UDP是一种简单的传输协议，所以它并不能提供可靠的数据传输，简单的说，UDP只是把应用程序发给它的数据打包成一个UDP数据报，然后再把这个数据报传给IP。</p>
<p>TCP会把应用程序发来的数据根据需要分成若干大小合适的TCP数据段，而UDP只是简单的把数据打包成一个UDP数据报，所以我们在编写使用UDP的程序时，不能一次性写入太多数据否则可能会导致IP分段的后果。</p>
</li>
<li><p>网络层</p>
<p>网络层关心的主要是如何把数据从一个设备发送到另一个设备。网络层需要提供三个主要功能：地址、路由分段和重组。同时还需要一些附加功能，比如错误处理和诊断。</p>
</li>
<li><p>数据链路层</p>
<p>网络层关心的是如何把数据从一个设备发送到另外一个设备，这另外一个设备有可能在本地网络中或者在一个很远的网络中。数据链路层关心的是如何把数据发送到本地网络中去。</p>
</li>
<li><p>物理层</p>
<p>物理层位于OSI的底层，所有其他层的数据最终都必须经由物理层才能发送出去。物理层的功能包括：</p>
<ul>
<li>硬件规范的定义，如电缆、连接器、无线接收器等的工作方式，网卡、集线器（Hub）等网络设备也工作在物理层。</li>
<li>编码和信号，物理层把计算机中的二进制0和1转换成可以在物理介质上传输的信号。</li>
<li>在把数据转换成信号后（如对于双绞线电缆则是电子脉冲信号），物理层负责信号的实际发送和接收。</li>
</ul>
</li>
</ul>
<h1 id="TCP-IP四层模型与OSI七层模型的对比关系"><a href="#TCP-IP四层模型与OSI七层模型的对比关系" class="headerlink" title="TCP/IP四层模型与OSI七层模型的对比关系"></a>TCP/IP四层模型与OSI七层模型的对比关系</h1><p><img src="https://user-gold-cdn.xitu.io/2018/4/27/1630526cea926fc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h1 id="TCP首部6个标志比特位"><a href="#TCP首部6个标志比特位" class="headerlink" title="TCP首部6个标志比特位"></a>TCP首部6个标志比特位</h1><p>可以设置1 或者 0 ，用来应答，它们分别表示的含义如下：</p>
<ol>
<li><p>URG：紧急指针</p>
</li>
<li><p>ACK：确认序号有效</p>
</li>
<li><p>PSH：尽可能快地将数据送往接受进程</p>
</li>
<li><p>RST：重建连接</p>
</li>
<li><p>SYN：同步序号用来发起连接</p>
</li>
<li><p>FIN：发送端完成发送任务</p>
</li>
</ol>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><ul>
<li>TCP是有连接的，两台主机在进行数据交互之前必须保证三次握手建立连接，而UDP是无连接的。</li>
<li>TCP是可靠的传输，TCP协议通过确认和重传机制来保证数据的可靠性，而UDP是不可靠的传输。</li>
<li>TCP还提供了拥塞控制、滑动窗口等机制来保证传输的质量而UDP没有。</li>
<li>TCP是基于字节流的，将数据看做无结构的字节流进行传输，当传输数据超出MSS时TCP就会对数据进行分段，因此TCP的数据是无边界的，而UDP是面向报文的无论应用程序交给UDP多长的报文，UDP都不会对数据进行任何的拆分处理，因此UDP保留的应用层数据边界。</li>
</ul>
<h1 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h1><ul>
<li><p>三次握手</p>
<p>第一次握手：客户端想与服务器建立连接传输数据，客户端向服务器端发送TCP连接报文请求，SYN = 1，seq (Sequence Number)= x，然后客户端进入SYN_SEND状态，等待服务器回复。</p>
<p>第二次握手：正处于listen状态的服务器端接受客户端发送的SYN报文后，表示我已经收到了请求，我可以与你建立连接，服务器端回复Ack = x +1表示接收到数据，同时包含服务器端的SYN请求请求信息：SYN = 1，seq=y，一并发送给客户端，此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：处于SYN_SEND状态的客户端，接收到服务器发送的报文，ACK=Y+1表示接受到信息的报文会回发给服务器表示知道服务器端收到了信息，进入establishen状态。</p>
<p>服务器端收到第三次握手后，进入ESTABLISHEN状态，完成三次握手 。</p>
</li>
<li><p>四次挥手</p>
<p>第一次挥手：客户端发送FIN标志位表示断开连接FIN=1，Seq=x+2，ACK=Y+1，然后客户端进入FIN_WAIT_1状态。</p>
<p>第二次挥手：服务器收到第一次挥手的请求后，后回复ACK=x+3进入CLOSE_WAIT状态</p>
<p>到三次挥手：服务器端向客户发送完最后数据后发送：FIN=1，Seq=y+1，然后服务器进入LAST_ACK状态</p>
<p>第四次挥手：客户端收到服务器发送的FIN报文，然后向服务器表示收到回复ACK=y+2就进入TIME_WAIT状态，服务器收到后就管理连接，此时客户端还会等待2MSL（最大报文段生存实时间）后，依然没有收到服务器任何回复就表示服务器端正常关闭，客户端关闭。</p>
</li>
</ul>
<h2 id="为什么握手需要三次，而挥手却需要四次？"><a href="#为什么握手需要三次，而挥手却需要四次？" class="headerlink" title="为什么握手需要三次，而挥手却需要四次？"></a>为什么握手需要三次，而挥手却需要四次？</h2><p>握手的时候，A和B打招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候A说我要断开了，B还没发完最后的数据，因此需要回应一下A，我收到了你的断开请求了但是我需要把最后的数据再传给你所以这里分成了两步：1.回应A 2.发送自己最后的数据。</p>
<h2 id="为什么A进入TIME-WAIT需要等待最大报文段生存时间后才能关闭？"><a href="#为什么A进入TIME-WAIT需要等待最大报文段生存时间后才能关闭？" class="headerlink" title="为什么A进入TIME_WAIT需要等待最大报文段生存时间后才能关闭？"></a>为什么A进入TIME_WAIT需要等待最大报文段生存时间后才能关闭？</h2><p>原因是，担心网络不可靠而导致的丢包，最后一个回应B的ACK万一丢了怎么办，在这个时间内A饰可以重新发包的，但是超过了最大的等待时间的话，就算收不到也没用了，所有就可以关闭了。</p>
<h2 id="Http报文"><a href="#Http报文" class="headerlink" title="Http报文"></a>Http报文</h2><p>HTTP请求由请求行、请求头、空行、和请求体四个部分组成。</p>
<p>HTTP响应由状态行、消息报头、和响应正文三个部分组成，请求和响应基本上都是相对的。</p>
<p>GET和POST的区别：</p>
<ol>
<li>Get请求能缓存，Post不能</li>
<li>POST相对于GET安全一点，因为GET的数据都包含在URL里，且会被浏览器保存历史记录，POST不会，但是在抓包的情况下是一样的。</li>
<li>POST可以通过request body来传输比GET更多的数据，GET没有这个技术</li>
<li>URL有长度限制，会影响GET请求，但是这个长度限制是浏览器规定的，不是RFC规定的</li>
<li>POST支持更多的编码类型且不对数据类型限制</li>
</ol>
<h3 id="1-1请求行"><a href="#1-1请求行" class="headerlink" title="1.1请求行"></a>1.1请求行</h3><p>请求主要由三部分组成：请求方法、请求URL、Http协议版本。</p>
<p>请求方法比较多：GET/POST/HEAD/PUT/DELETE/OPTIONS/TRACE/CONNECT</p>
<h3 id="1-1请求头部"><a href="#1-1请求头部" class="headerlink" title="1.1请求头部"></a>1.1请求头部</h3><p>请求头部由关键字/值对组成，每行一对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">User-Agent：产生请求的浏览器类型；</span><br><span class="line">Content-type：发送端发送的实体数据的数据类型。比如text/html(application/json)表示发送的是html类型；</span><br><span class="line">Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机；</span><br><span class="line">Accept：客户端希望接受的数据类型，比如:text/xml(application/json)；</span><br><span class="line">Accept-Charset：表示客户端支持的字符集。例如：GB2312,ISO-8859-1;</span><br><span class="line">Accept-Encoding：表示客户端支持的内容编码格式。如gzip;</span><br><span class="line">	常用的内容编码：</span><br><span class="line">	gzip：由文件压缩程序gzip生成的编码格式；</span><br><span class="line">	compress：由UNIX文件压缩程序compress生成的编码格式；</span><br><span class="line">	defalte：组合使用zlib和defalte压缩算法生成的编码格式；</span><br><span class="line">	identity：默认的编码格式，不执行压缩；</span><br><span class="line">Accept-Language：表示客户端支持的语言。如：zh-cn；</span><br><span class="line">If-None-Match：If-None-Match的值对应所请求资源的ETag值（实体标记，与资源相关联，nginx采</span><br><span class="line">用文件最后修改时间的16进制加文件长度的16进制合成）一致时服务期会相应304（协商缓存）。</span><br><span class="line"></span><br><span class="line">If-Modified-Since：用于确认客户端拥有的本地资源的时效性，如果本地资源在指定时间后发生了改变，则服务期处理该请求，如果未改变就返回304(采用协商缓存)。</span><br><span class="line"></span><br><span class="line">If-Range：如果实体未改变，服务期发送客户端丢失的部分，否则发送整个实体。参数也为Etag。</span><br><span class="line"></span><br><span class="line">cookie：HTTP请求发送时，会把保存在该请求域名下的所有cookie值发送给服务器。</span><br><span class="line"></span><br><span class="line">Content-length：请求的内容长度。</span><br><span class="line"></span><br><span class="line">Date：请求发送的日期和时间。</span><br><span class="line"></span><br><span class="line">Connection：表示是否需要持久连接（HTTP1.1默认进行持久连接）。</span><br><span class="line"></span><br><span class="line">Cache-Control：指定请求和响应遵循的缓存机制。</span><br></pre></td></tr></table></figure>
<h2 id="1-2响应体"><a href="#1-2响应体" class="headerlink" title="1.2响应体"></a>1.2响应体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges：表明服务器是否支持指定范围请求及哪种类型的分段请求。</span><br><span class="line">Allow：对某网络资源的有效的请求行为，不允许则返回405.</span><br><span class="line">Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型。</span><br><span class="line">Content-Encoding：web服务器支持的返回内容压缩编码类型。</span><br><span class="line">Content-Language：响应体的语言。</span><br><span class="line">Content-Length：响应体的长度。</span><br><span class="line">Date：原始服务器消息发出的时间。</span><br><span class="line">Etag：请求变量的实体标签的当前值。</span><br><span class="line">Expires：响应过期的日期和时间。</span><br><span class="line">Last-Modified：请求资源的最后修改时间。</span><br></pre></td></tr></table></figure>
<h1 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h1><p>dns（Domain Name Ststem）的作用非常简单，就是根据域名查询出Ip地址，你可以把它想象成一个巨大的电话本。</p>
<h2 id="1-1DNS服务器"><a href="#1-1DNS服务器" class="headerlink" title="1.1DNS服务器"></a>1.1DNS服务器</h2><p>举例说明，本机是如何得到’<a href="http://www.baidu.com&#39;的IP地址，" target="_blank" rel="noopener">www.baidu.com&#39;的IP地址，</a></p>
<p>首先，本机一定要知道DNS服务期的IP地址，否则上不了网，通过DNS服务期才能知道某个域名的IP到底是什么。</p>
<p>DNS服务期怎么会知道每个域名的IP地址呢，答案是分级查询。</p>
<p>每个域名其实都有一个根域名举例简单来说<a href="http://www.yun.com" target="_blank" rel="noopener">www.yun.com</a> 真正的域名是 <a href="http://www.yun.com.root，简写为www.yun.com" target="_blank" rel="noopener">www.yun.com.root，简写为www.yun.com</a> 是因为根域名.root对于所有域名都是一样的，平时都是省略的。</p>
<p>根域名的下一级，叫做‘顶级域名’（top-level domain 缩写为TLD），比如.com、.net再下一级叫做次级域名‘（second-level domain,缩写SLD）比如<a href="http://www.yun.com里的.yun" target="_blank" rel="noopener">www.yun.com里的.yun</a> 这一级域名是用户可以注册的，再下一级是主机名，比如<a href="http://www.yun.com里面的www,又称’三级域名‘，这是用户在自己的域里面为服务期分配的名称，是用户可以任意分配的。" target="_blank" rel="noopener">www.yun.com里面的www,又称’三级域名‘，这是用户在自己的域里面为服务期分配的名称，是用户可以任意分配的。</a></p>
<p>客户端向本地DNS服务器做递归查询，本地DNS服务器对域名服务器做迭代查询。</p>
<p>总域名层级结构：主机名. 次级域名 . 顶级域名 . 根域名 即 host.sld.tld.root</p>
<h2 id="1-2根域名服务器"><a href="#1-2根域名服务器" class="headerlink" title="1.2根域名服务器"></a>1.2根域名服务器</h2><p>dns服务期根据域名的层级，进行分级查询。</p>
<p>需要明确的是，每一级域名都有自己的NS记录（一个域名服务器记录），NS记录指向该域名的域名服务器。这些服务期知道下一级域名的各种记录。</p>
<p>所谓’分级查询‘，就是从根域名开始，依次查询每一级域名的NS记录，直到返回IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从’根域名服务器‘查到’顶级域名服务器‘的NS记录和A记录（IP地址）</span><br><span class="line">2.从’顶级域名服务期‘查到’次级域名服务期‘的NS记录和A记录（IP地址）</span><br><span class="line">3.从’次级域名服务期‘查出’主机名‘的IP地址</span><br></pre></td></tr></table></figure>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>Http2.0相比较于Http1.x，可以说是大幅度的提高了web的性能。</p>
<p>在Http1.x中，为了性能考虑我们会减少请求，使用多个域名等方式，这一切都是为了浏览器限制了一个域名下建立的TCP链接数量所作的优化，当页面中需要请求很多资源的时候，队头阻塞会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p>
<h3 id="二进制分帧传输"><a href="#二进制分帧传输" class="headerlink" title="二进制分帧传输"></a>二进制分帧传输</h3><p>Http2.0中所有的加强性能的核心点在于此，在此前的HTTP版本中，我们是通过文本的方式传输数据，在Http2.0中引入了新的编码机制，所有传输的数据都会被分割并采用二进制编码。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在Http2.0中，有两个非常重要的概念，分别是帧和流。</p>
<p>帧代表者最小的数据单位，每个帧都会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<p>多路复用，就是一个TCP连接中可以存在多条流，换句话说可以发送多个请求，对端可以通过帧中的标识分辨是属于哪个请求，通过 这个技术可以避免HTTP旧版本中的队头阻塞问题，极大的提高了传输性能。</p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在HTTP1.X中，我们使用文本的形式传输头部，在头部携带cookie的情况下，可能每次都需要重复传输数据。</p>
<p>在HTTP2.0中，使用了HPACK压缩格式对传输的头部进行编码，减少了头部的大小。并在两段维护了索引表，用于记录之前传输过的头部，后面在传输过程中通过传输索引对端收到索引后就可以获取对应的值。</p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。</p>
<p>可以想象以下情况，某些资源是客户端一定会请求的，这时候就可以采用服务端推送技术，提前给客户端推送必要的资源，这样就可以减少一点延时时间，当然在浏览器兼容的情况下你也可以使用prefetch.</p>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>这是一个谷歌出品基于UDP实现的同为传输层的协议，目标很远大，希望替代TCP协议。</p>
<ul>
<li>该协议支持多路复用，虽然HTTP2.0也支持多路复用，但是下层仍是TCP，因为TCP的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞问题，但是UDP没有这个机制。</li>
<li>实现了自己的加密协议，通过类似TCP的TFO机制可以实现0-RTT，当然TLS1.3已经实现了0-RTT了</li>
<li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul>
<li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值算出丢死包</li>
<li>在丢失两个包或者以上的情况下就使用重传机制，因为算不过来了</li>
</ul>
</li>
</ul>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/06/07/深入浏览器理解CSS animations 和transitions的性能问题/" class="pre">深入浏览器理解css动画和过渡</a><a href="/2018/01/21/移动端适配/" class="next">移动端适配</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#网络分层TCP-IP-与HTTP"><span class="toc-text">网络分层TCP/IP 与HTTP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSI模型"><span class="toc-text">OSI模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-IP四层模型与OSI七层模型的对比关系"><span class="toc-text">TCP/IP四层模型与OSI七层模型的对比关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP首部6个标志比特位"><span class="toc-text">TCP首部6个标志比特位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP和UDP的区别"><span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP三次握手和四次挥手"><span class="toc-text">TCP三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么握手需要三次，而挥手却需要四次？"><span class="toc-text">为什么握手需要三次，而挥手却需要四次？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么A进入TIME-WAIT需要等待最大报文段生存时间后才能关闭？"><span class="toc-text">为什么A进入TIME_WAIT需要等待最大报文段生存时间后才能关闭？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http报文"><span class="toc-text">Http报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1请求行"><span class="toc-text">1.1请求行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1请求头部"><span class="toc-text">1.1请求头部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2响应体"><span class="toc-text">1.2响应体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DNS是什么"><span class="toc-text">DNS是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1DNS服务器"><span class="toc-text">1.1DNS服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2根域名服务器"><span class="toc-text">1.2根域名服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP2-0"><span class="toc-text">HTTP2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制分帧传输"><span class="toc-text">二进制分帧传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用"><span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#头部压缩"><span class="toc-text">头部压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端推送"><span class="toc-text">服务端推送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC"><span class="toc-text">QUIC</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/网络相关总结(2)/">网络相关(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/深入浏览器理解CSS animations 和transitions的性能问题/">深入浏览器理解css动画和过渡</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/网络相关总结(1)/">网络相关(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/21/移动端适配/">移动端适配</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/20/Http缓存机制/">Http缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/数据结构相关/">数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/03/js严格模式/">js严格模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/react全局变量/">react全局变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/Js连等赋值/">Js连等赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/常见的Http状态码/">常见的Http状态码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">张云辉.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>